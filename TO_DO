1. Each time pycresta creates a new directory with subtomograms, please write all information about settings and inputs as a text 
file into that directory, i.e., project text file. So, if the user performs filtering, the file should contain the information about
the particular settings and inputs that were used for the filtering job. -->> OK, but please also do for Gaussian.

2. Incorporate calc angles directly into extraction as an option. Ask user to specify the file extensions for the start and end point coordinates rather than full path names. Should
work for both single tomogram directories as well as batch mode with multiple tomograms in one directory.

3. Fix inverse Euler angle issue in Plot Back. 

Hi Axel and Patrick,
Using this package: https://eulerangles.readthedocs.io/en/latest/usage/quick_start.html

I was looking at the one that is 90, 0 , -90, and the correct angles should be 0 0 0.  
So:
>>> input_eulers = np.array([90, 0, -90])
>>> output_euler=euler2euler( input_eulers, source_axes='zyz', source_intrinsic=True, source_right_handed_rotation=True, target_axes='zyz', target_intrinsic=False, target_right_handed_rotation=False, invert_matrix=True)
>>> print(output_euler)
[-0. -0. -0.]
>>>


And that should be correct as far as I could tell. So I think we just need to use this to properly invert the angles and we should be good to go.
Cheers,
-J

-- new to do (after Augst 6, 2023)
4. write info about star file, and populate Master Key at end of: Calcuate Angles, Modify -> Rotate... and -> Rotate Manaully. 

5. Set zero angles in star file after rottrans.

6. Extraction assumes the coords file is an integer with a single space between coordinate points (i.e. "int1 int2 int3"). 
This isn't the default output of IMOD model2point - at least my version - which defaults to float and 
tab separated values ("    float1    float2    float3"). You can add a flag to force integer output, 
but the tab separation is locked in. It looks like the code uses line.split(' ') to break up 
each input line, so tabs are broken into multiple indexes and you end up passing a space to int(pos[idx]).  
Comma separated values also fail for the same reason since the string cannot be converted to int. 

-> Just have python convert to an integer, ignoring what imod does entirely?


7. manual (x,y,z) rottrans produces sometimes bus error when operating on previously rotated volumes:

- the issue is this statement in def processParticler in tom.py

   outH1 = cut_out(outH1, np.array([0, 0, 0]), boxsize)
   
   I commented it out - it is only used in that place. It makes the box smaller if there are values < 1? This does not make much sense!
   
   it produces a box that is 255,255,255 rather than 256,256,256. This mismatch causes issues with subsequent rotate commands.
   
 - another issue is the interpolation exception treatment in rot3d.c. I reverted back to the original code, but included additional cushion:
 
 - finally, I calculate the mean of the image density and use that for the pixels outside the range.
 
 /* ATB */
 /* Calculate mean of image array */
 image_size=sx*sy*sz;
 image_sum=0;
 for(i = 0; i < image_size; ++i)
    image_sum += image[i];
    image_mean = image_sum/image_size;
 /*   printf("image mean: %f %ld /n",image_mean, image_size); */
 
 ....
 
				/* ATB: modified these tests to test if the pixel +/-1 (in all 3 dimensions) is outside the range of the original image */
				/* this is to make ensure that the interpolation does not access pixels that are not in the original image */
				/* Outside values are set to the mean of the image array */
				r_x = px + rm00 * pi + rm10 * pj + rm20 * pk;
				/* orig: if (r_x < 0 || r_x > sx_1 ) */
				if (r_x < 1 || r_x > sx_1-1 ) 
				{
					*rotimg++ = image_mean;  /* this pixel was not inside the image */
					continue;
				} 
				r_y = py + rm01 * pi + rm11 * pj + rm21 * pk;
				/* orig: if (r_y < 0 || r_y > sy_1 ) */
				if (r_y < 1 || r_y > sy_1-1 ) 
				{
					*rotimg++ = image_mean;
					continue;
				} 
				r_z = pz + rm02 * pi + rm12 * pj + rm22 * pk;
				/* orig: if (r_z < 0 || r_z > sz_1 ) */
				if (r_z < 1 || r_z > sz_1-1 ) 
				{
					*rotimg++ = image_mean;
					continue;
				} 

 
  8. Please add a test to ensure that the box dimensions match those of the subtomogram in the rotate function, prior to calling the rot3d.c function
   

 
 
 
----


Other: 

4. Try Chimerax plugin ArtiaX, https://pubmed.ncbi.nlm.nih.gov/36251681/, https://onlinelibrary.wiley.com/doi/10.1002/pro.4472  Any comments?

5. Add the box size and pixel size as a comment into the cmm files? For future.

6. Memory mapping for Filtering? Not possible.



